name: Lichess Bot Runner

concurrency:
  group: lichess-bot-runner
  cancel-in-progress: true

on:
  workflow_dispatch:
    inputs:
      mode:
        description: 'Bot Mode'
        type: choice
        required: true
        options:
          - normal
          - matchmaking
          - tournament
      tournament_id:
        description: 'Tournament ID (if tournament mode)'
        type: string
        required: false
      team_id:
        description: 'Team ID (optional)'
        type: string
        required: false
      password:
        description: 'Tournament password (optional)'
        type: string
        required: false
  schedule:
    - cron: '0 */6 * * *'  # every 6 hours
  push:
    branches: [ main ]
    paths:
      - '**.py'
      - 'config.yml'

permissions:
  actions: write
  contents: write

jobs:
  bot-runner:
    runs-on: ubuntu-latest
    timeout-minutes: 355  # restart just before GitHub limit

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v5

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Install Dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install tenacity pyyaml

      - name: Build wordfish 
        env:
          WORDFISH_PAT: ${{ secrets.WORDFISH_PAT }}
          GITHUB_WORKSPACE: ${{ github.workspace }}
        shell: bash
        run: |
          set -euo pipefail
          set -x

          # fresh clone
          rm -rf wordfish || true
          if [ -n "${WORDFISH_PAT:-}" ]; then
            git clone "https://x-access-token:${WORDFISH_PAT}@github.com/FayE75/wordfish.git" wordfish
          else
            git clone https://github.com/FayE75/wordfish.git wordfish
          fi

          sudo apt-get update -qq
          sudo apt-get install -y build-essential clang clang++ lld llvm-dev pkg-config cmake ninja-build curl unzip file || true

          cd wordfish || { echo "wordfish dir missing"; exit 1; }

          # optional network script
          if [ -f "scripts/net.sh" ]; then
            cd src && sh ../scripts/net.sh || true
            cd ..
          fi

          if [ -d "src" ]; then
            cd src

            echo "🔧 CLEAN old artifacts"
            make clean || true
            rm -f *.o *.a wordfish || true

            echo "🔎 Removing -flto occurrences from Makefiles / *.mk to avoid LTO objects"
            # be aggressive: remove common -flto patterns in all text files under src
            grep -RI --line-number --binary-files=without-match -e "\-flto" . || true
            # Remove -flto and related tokens from files in-place (backup .bak)
            find . -type f -name '*' -exec sed -i.bak -e 's/-flto[[:alnum:]=-]*//g' -e 's/-flto-partition=[^[:space:]]*//g' -e 's/-flto=jobserver//g' {} +

            # force consistent compilers and disable LTO via flags
            export CC=clang
            export CXX=clang++
            export AR=ar
            export RANLIB=ranlib
            export CFLAGS="-fno-lto ${CFLAGS:-}"
            export CXXFLAGS="-fno-lto ${CXXFLAGS:-}"
            export LDFLAGS=""

            echo "🔧 Building (COMP=clang, no LTO) - logging to ../build_logs/build.log"
            mkdir -p ../build_logs || true

            # run make, capture exit code robustly
            set +e
            make -j2 build ARCH=x86-64-sse41-popcnt COMP=clang V=1 | tee ../build_logs/build.log
            MAKE_RC=${PIPESTATUS[0]:-1}
            set -e

            if [ "${MAKE_RC}" -ne 0 ]; then
              echo "❌ Build failed. Inspecting possible broken object files (uci.o, etc.)"

              # show last lines of log
              tail -n 200 ../build_logs/build.log || true

              # check uci.o if exists
              if [ -f uci.o ]; then
                echo "---- file uci.o ----"
                file uci.o || true
                echo "---- hexdump head of uci.o (first 256 bytes) ----"
                hexdump -C -n 256 uci.o || true
                echo "---- readelf (if possible) ----"
                readelf -h uci.o || true
              else
                echo "uci.o not present in src/ (maybe compiled elsewhere). Listing *.o:"
                ls -lah *.o || true
              fi

              echo "Attempting rebuild from scratch: remove all .o and rebuild"
              rm -f *.o *.a wordfish || true
              set +e
              make -j1 build ARCH=x86-64-sse41-popcnt COMP=clang V=1 | tee ../build_logs/build_rebuild.log
              REBUILD_RC=${PIPESTATUS[0]:-1}
              set -e

              if [ "${REBUILD_RC}" -ne 0 ]; then
                echo "❗ Rebuild still failed. Uploading logs and exiting."
                tail -n 300 ../build_logs/build_rebuild.log || true
                exit 1
              fi
            fi

            cd ..
          else
            echo "❌ src directory missing; cannot build"
            exit 1
          fi

          # copy built binary if exists
          BIN_PATH=$(find . -type f -executable -iname 'stockfish*' -o -iname 'wordfish*' -print -quit || true)
          if [ -n "$BIN_PATH" ]; then
            mkdir -p "${GITHUB_WORKSPACE}/engines"
            cp "$BIN_PATH" "${GITHUB_WORKSPACE}/engines/wordfish" || true
            chmod +x "${GITHUB_WORKSPACE}/engines/wordfish" || true
            echo "✅ Engine copied to engines/wordfish"
          else
            echo "⚠️ No engine binary found after build"
          fi

          # copy logs
          if [ -d build_logs ]; then
            cp -r build_logs "${GITHUB_WORKSPACE}/build_logs" || true
          fi

      - name: Diagnose engine binary (wordfish) and run UCI handshake
        if: always()
        env:
          GITHUB_WORKSPACE: ${{ github.workspace }}
        shell: bash
        uses: actions/upload-artifact@v4
        run: |
          set -euo pipefail
          mkdir -p engine_diagnose || true
          cd engine_diagnose

          # Paths
          ENGINE_FILE="../engines/wordfish"
          echo "Checking: $ENGINE_FILE"

          # 1) Exists & executable?
          if [ ! -f "$ENGINE_FILE" ]; then
            echo "ERROR: engine binary not found at $ENGINE_FILE"
            ls -lah ../engines || true
            exit 2
          fi
          ls -lah "$ENGINE_FILE"
          chmod +x "$ENGINE_FILE" || true

          # 2) File type (arch)
          echo "--- file output ---" > engine_info.txt
          file "$ENGINE_FILE" >> engine_info.txt 2>&1

          # 3) ldd (shared libs) - may fail on some systems; capture result
          echo "--- ldd output ---" >> engine_info.txt
          if command -v ldd >/dev/null 2>&1; then
            ldd "$ENGINE_FILE" >> engine_info.txt 2>&1 || true
          else
            echo "ldd not available" >> engine_info.txt
          fi

          # 4) Run a UCI handshake simulation (capture stdout/stderr).
          # Send UCI init, then isready (timeout 10s) then quit.
          echo "=== Running UCI handshake (stdout+stderr captured) ===" > engine_run.log
          # Use a tiny timeout to avoid blocking if binary hangs (needs 'timeout' installed)
          if command -v timeout >/dev/null 2>&1; then
            timeout 15s bash -lc 'printf "uci\nisready\nquit\n" | '"$ENGINE_FILE"'' >> engine_run.log 2>&1 || true
          else
            bash -lc 'printf "uci\nisready\nquit\n" | '"$ENGINE_FILE"'' >> engine_run.log 2>&1 || true
          fi

          # 5) If strace available, run short trace to see syscalls (may require apt install)
          if command -v strace >/dev/null 2>&1; then
            echo "=== strace short (first 200 lines) ===" >> engine_run.log
            timeout 6s strace -o strace.log -f "$ENGINE_FILE" </dev/null || true
            head -n 200 strace.log >> engine_run.log || true
          else
            echo "strace not installed; skipping strace" >> engine_run.log
          fi

          # Save logs for artifact upload
          cp engine_info.txt ../build_logs/engine_info.txt || true
          cp engine_run.log ../build_logs/engine_run.log || true
          [ -f strace.log ] && cp strace.log ../build_logs/strace.log || true

          echo "DIAGNOSTIC OUTPUT:"
          tail -n 100 engine_run.log || true

      - name: Upload engine diagnose logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: engine-diagnose-logs
          path: wordfish/../build_logs

      - name: Setup Engines
        run: |
          mkdir -p engines
          sudo apt-get update && sudo apt-get install -y unzip || true
          # If we have engines placed already by previous step, ensure they are executable
          if [ -f "engines/wordfish" ]; then chmod +x engines/wordfish; fi
          if [ -f "engines/stockfish" ]; then chmod +x engines/stockfish; fi
          if [ -f "engines/fsf" ]; then chmod +x engines/fsf; fi
          if [ -f "engines/ShashChess39" ]; then chmod +x engines/ShashChess39; fi

      - name: Inject Lichess Bot Token
        env:
          LICHESS_TOKEN: ${{ secrets.LICHESS_TOKEN }}
        run: |
          python3 << 'EOF'
          import os, yaml, sys
          token = os.environ.get("LICHESS_TOKEN")
          if not token:
              print("ERROR: LICHESS_TOKEN secret is missing!")
              sys.exit(1)
          cfg_path = "config.yml"
          cfg = {}
          if os.path.exists(cfg_path):
              with open(cfg_path,"r") as f:
                  cfg = yaml.safe_load(f) or {}
          cfg["token"] = token
          with open(cfg_path,"w") as f:
              yaml.dump(cfg,f, default_flow_style=False)
          print("✅ Token injected successfully")
          EOF

      - name: Launch Bot
        run: |
          CMD_BASE="python3 -u user_interface.py"
          MODE="${{ github.event.inputs.mode }}"
          TOUR_ID="${{ github.event.inputs.tournament_id }}"
          TEAM_ID="${{ github.event.inputs.team_id }}"
          PASSWORD="${{ github.event.inputs.password }}"

          if [[ "$MODE" == "matchmaking" ]]; then
              CMD="$CMD_BASE matchmaking"
              echo "🤖 Running command: $CMD"
              eval "$CMD"

          elif [[ "$MODE" == "tournament" ]]; then
              if [[ -z "$TOUR_ID" ]]; then
                  echo "⚠️ Tournament ID missing. Skipping."
              else
                  ARGS="$TOUR_ID"
                  [[ -n "$TEAM_ID" ]] && ARGS="$ARGS $TEAM_ID"
                  [[ -n "$PASSWORD" ]] && ARGS="$ARGS $PASSWORD"

                  echo "🤖 Joining tournament: $ARGS"
                  eval "$CMD_BASE \"tournament $ARGS\""
              fi

          else
              echo "⚠️ Mode not recognized. Running normal mode."
              eval "$CMD_BASE"
          fi

      - name: Auto-Restart After Timeout
        run: |
          # NOTE: This step can't control the previous step's process.
          # If you want an auto-restart supervisor, run inside the Launch Bot step (loop + timeout).
          echo "Auto-restart step present but control must be implemented inside the bot process/launcher if needed."
