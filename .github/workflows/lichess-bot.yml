name: Lichess Bot Runner

concurrency:
  group: lichess-bot-runner
  cancel-in-progress: true

on:
  workflow_dispatch:
    inputs:
      mode:
        description: 'Bot Mode'
        type: choice
        required: true
        options:
          - normal
          - matchmaking
          - tournament
      tournament_id:
        description: 'Tournament ID (if tournament mode)'
        type: string
        required: false
      team_id:
        description: 'Team ID (optional)'
        type: string
        required: false
      password:
        description: 'Tournament password (optional)'
        type: string
        required: false
  schedule:
    - cron: '0 */6 * * *'  # every 6 hours
  push:
    branches: [ main ]
    paths:
      - '**.py'
      - 'config.yml'

permissions:
  actions: write
  contents: write

jobs:
  bot-runner:
    runs-on: ubuntu-latest
    timeout-minutes: 355  # restart just before GitHub limit

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v5

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Install Dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install tenacity pyyaml

      - name: Build wordfish (clone + build + perft) (LTO-compatible)
        env:
          WORDFISH_PAT: ${{ secrets.WORDFISH_PAT }}
          GITHUB_WORKSPACE: ${{ github.workspace }}
        run: |
          set -euo pipefail
          rm -rf wordfish || true

          # Clone (use PAT for private repo)
          if [ -z "${WORDFISH_PAT:-}" ]; then
            echo "ERROR: WORDFISH_PAT secret is missing"; exit 1
          fi
          git clone https://x-access-token:${WORDFISH_PAT}@github.com/FayE75/wordfish.git wordfish

          # Install toolchain (try to install specific clang-18 stack; fallback to clang)
          sudo apt-get update -qq
          # try to install versioned packages (may or may not exist on runner); ignore failure but continue
          sudo apt-get install -y clang-18 lld-18 llvm-18-dev llvm-18 llvm-toolchain-18 pkg-config cmake ninja-build curl unzip || true
          # Also install plain packages to ensure basic tools
          sudo apt-get install -y build-essential clang lld llvm-dev pkg-config cmake ninja-build curl unzip || true

          cd wordfish || { echo "wordfish dir missing"; exit 1; }

          # optional network setup for NN files
          if [ -f "scripts/net.sh" ]; then
            cd src && sh ../scripts/net.sh || true
            cd ..
          fi

          # Build in src
          if [ -d "src" ]; then
            cd src
            mkdir -p ../build_logs
            echo "üîß Clean"
            make clean || true

            # Pick the best available clang/lld/llvm-ar/randlib
            if command -v clang-18 >/dev/null 2>&1; then
              export CC=clang-18
              export CXX=clang++-18
            elif command -v clang >/dev/null 2>&1; then
              export CC=clang
              export CXX=clang++
            else
              echo "ERROR: no clang found"; exit 1
            fi

            # pick lld and llvm-ar / ranlib if available
            if command -v lld-18 >/dev/null 2>&1; then
              export LDFLAGS="-fuse-ld=lld-18 ${LDFLAGS:-}"
            elif command -v lld >/dev/null 2>&1; then
              export LDFLAGS="-fuse-ld=lld ${LDFLAGS:-}"
            else
              echo "WARNING: lld not found; linking may fallback to system ld"
              export LDFLAGS="${LDFLAGS:-}"
            fi

            if command -v llvm-ar-18 >/dev/null 2>&1; then
              export AR=llvm-ar-18
            elif command -v llvm-ar >/dev/null 2>&1; then
              export AR=llvm-ar
            else
              export AR=ar
            fi

            if command -v llvm-ranlib-18 >/dev/null 2>&1; then
              export RANLIB=llvm-ranlib-18
            elif command -v llvm-ranlib >/dev/null 2>&1; then
              export RANLIB=llvm-ranlib
            else
              export RANLIB=ranlib
            fi

            echo "Using toolchain: CC=$CC CXX=$CXX AR=$AR RANLIB=$RANLIB LDFLAGS=$LDFLAGS"

            # Make verbose and save logs
            echo "üîß Building (LTO-capable) - logging to ../build_logs/build.log"
            if ! make -j2 build ARCH=x86-64-sse41-popcnt COMP=clang V=1 2>&1 | tee ../build_logs/build.log; then
              echo "‚ùå Build failed ‚Äî showing last 400 lines of build.log"
              tail -n 400 ../build_logs/build.log || true

              # Collect object file diagnostics (helpful to see bitcode vs ELF)
              echo "---- object files summary ----"
              ls -lah *.o || true
              for f in *.o 2>/dev/null || true; do
                echo "---- file info for: $f ----"
                file "$f" || true
                echo "---- readelf header for: $f ----"
                # readelf will print error for LLVM bitcode (that's okay)
                readelf -h "$f" || true
              done || true

              # Dump first few bytes of a failing object if present (useful to detect bitcode magic)
              if [ -f tt.o ]; then
                echo "---- tt.o hexdump (head) ----"
                hexdump -C tt.o | sed -n '1,6p' || true
              fi

              echo "‚ùó Build failed. See build_logs/build.log for full output (attached to job workspace)."
              exit 1
            fi

            # back to repo root
            cd ..
          else
            echo "‚ùå src directory missing; cannot build"
            exit 1
          fi

          # Run perft tests if available (best-effort)
          if [ -d "tests" ]; then
            echo "‚ñ∂Ô∏è Running tests/perft.sh (best-effort)"
            cd tests && bash perft.sh || true
            cd ..
          else
            echo "‚ö†Ô∏è tests directory missing; skipping perft"
          fi

          # Find built binary and copy it to top-level engines folder
          BIN_PATH=$(find . -type f -executable -iname 'stockfish*' -o -iname 'wordfish*' -print -quit || true)
          if [ -z "$BIN_PATH" ]; then
            BIN_PATH=$(find src -type f -executable -iname 'stockfish*' -o -iname 'wordfish*' -print -quit || true)
          fi

          mkdir -p "${GITHUB_WORKSPACE}/engines"
          if [ -n "$BIN_PATH" ]; then
            echo "‚úÖ Found built engine: $BIN_PATH"
            cp "$BIN_PATH" "${GITHUB_WORKSPACE}/engines/wordfish" || true
            chmod +x "${GITHUB_WORKSPACE}/engines/wordfish" || true
            echo "‚úÖ Engine copied to engines/wordfish"
          else
            echo "‚ö†Ô∏è No engine binary found after build"
          fi

          # Save build logs to workspace for later steps to upload if you add an artifact upload step
          if [ -d build_logs ]; then
            cp -r build_logs "${GITHUB_WORKSPACE}/build_logs" || true
          fi


      - name: Setup Engines
        run: |
          mkdir -p engines
          sudo apt-get update && sudo apt-get install -y unzip || true
          if [ -f "engines/wordfish" ]; then chmod +x engines/wordfish; fi
          if [ -f "engines/fsf" ]; then chmod +x engines/fsf; fi
          if [ -f "engines/ShashChess39" ]; then chmod +x engines/ShashChess39; fi

      - name: Inject Lichess Bot Token
        env:
          LICHESS_TOKEN: ${{ secrets.LICHESS_TOKEN }}
        run: |
          python3 << 'EOF'
          import os, yaml, sys
          token = os.environ.get("LICHESS_TOKEN")
          if not token:
              print("ERROR: LICHESS_TOKEN secret is missing!")
              sys.exit(1)
          cfg_path = "config.yml"
          cfg = {}
          if os.path.exists(cfg_path):
              with open(cfg_path,"r") as f:
                  cfg = yaml.safe_load(f) or {}
          cfg["token"] = token
          with open(cfg_path,"w") as f:
              yaml.dump(cfg,f, default_flow_style=False)
          print("‚úÖ Token injected successfully")
          EOF

      - name: Launch Bot
        run: |
          CMD_BASE="python3 -u user_interface.py"
          MODE="${{ github.event.inputs.mode }}"
          TOUR_ID="${{ github.event.inputs.tournament_id }}"
          TEAM_ID="${{ github.event.inputs.team_id }}"
          PASSWORD="${{ github.event.inputs.password }}"

          if [[ "$MODE" == "matchmaking" ]]; then
              CMD="$CMD_BASE matchmaking"
              echo "ü§ñ Running command: $CMD"
              eval "$CMD"

          elif [[ "$MODE" == "tournament" ]]; then
              if [[ -z "$TOUR_ID" ]]; then
                  echo "‚ö†Ô∏è Tournament ID missing. Skipping."
              else
                  ARGS="$TOUR_ID"
                  [[ -n "$TEAM_ID" ]] && ARGS="$ARGS $TEAM_ID"
                  [[ -n "$PASSWORD" ]] && ARGS="$ARGS $PASSWORD"

                  echo "ü§ñ Joining tournament: $ARGS"
                  eval "$CMD_BASE \"tournament $ARGS\""
              fi

          else
              echo "‚ö†Ô∏è Mode not recognized. Running normal mode."
              eval "$CMD_BASE"
          fi

      - name: Auto-Restart After Timeout
        run: |
          echo "Auto-restart step present but control must be implemented inside the bot process/launcher if needed."
